<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>nodejs流 | teefing休憩小站</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/icon/logo.png">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icon/apple-touch-icon-144x144.png">
    <link rel="mask-icon" href="/icon/safari-pinned-tab.svg" color="#3eaf7c">
    <meta name="description" content="前端路上点点滴滴">
    <meta name="theme-color" content="#3eaf7c">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/icon/msapplication-icon-144x144.png">
    <meta name="msapplication-TileColor" content="#fff">
    <link rel="preload" href="/assets/css/0.styles.3bf0f48a.css" as="style"><link rel="preload" href="/assets/js/app.9da2ff31.js" as="script"><link rel="preload" href="/assets/js/7.8bf351e1.js" as="script"><link rel="preload" href="/assets/js/52.2d5e3f14.js" as="script"><link rel="prefetch" href="/assets/js/1.ba5ed28b.js"><link rel="prefetch" href="/assets/js/10.b09d163f.js"><link rel="prefetch" href="/assets/js/11.9ee4ab9a.js"><link rel="prefetch" href="/assets/js/12.672e3ffc.js"><link rel="prefetch" href="/assets/js/13.eb7c0593.js"><link rel="prefetch" href="/assets/js/14.8860f689.js"><link rel="prefetch" href="/assets/js/15.af89524d.js"><link rel="prefetch" href="/assets/js/16.ab5e5610.js"><link rel="prefetch" href="/assets/js/17.46710159.js"><link rel="prefetch" href="/assets/js/18.beb740af.js"><link rel="prefetch" href="/assets/js/19.1e538512.js"><link rel="prefetch" href="/assets/js/20.221d0ddd.js"><link rel="prefetch" href="/assets/js/21.5b6290be.js"><link rel="prefetch" href="/assets/js/22.888d45b1.js"><link rel="prefetch" href="/assets/js/23.ff1753f4.js"><link rel="prefetch" href="/assets/js/24.e9f2bc44.js"><link rel="prefetch" href="/assets/js/25.9318d601.js"><link rel="prefetch" href="/assets/js/26.7667f570.js"><link rel="prefetch" href="/assets/js/27.71a0c5fb.js"><link rel="prefetch" href="/assets/js/28.66c38584.js"><link rel="prefetch" href="/assets/js/29.773031ab.js"><link rel="prefetch" href="/assets/js/3.b4e50186.js"><link rel="prefetch" href="/assets/js/30.6088f0c5.js"><link rel="prefetch" href="/assets/js/31.1cec2200.js"><link rel="prefetch" href="/assets/js/32.bd7daa35.js"><link rel="prefetch" href="/assets/js/33.b2a2016c.js"><link rel="prefetch" href="/assets/js/34.32a327f2.js"><link rel="prefetch" href="/assets/js/35.42721d7c.js"><link rel="prefetch" href="/assets/js/36.f5405dae.js"><link rel="prefetch" href="/assets/js/37.29bdb151.js"><link rel="prefetch" href="/assets/js/38.a66e1e0c.js"><link rel="prefetch" href="/assets/js/39.84d396b2.js"><link rel="prefetch" href="/assets/js/4.61992307.js"><link rel="prefetch" href="/assets/js/40.b1a0b3eb.js"><link rel="prefetch" href="/assets/js/41.417bff84.js"><link rel="prefetch" href="/assets/js/42.e8680721.js"><link rel="prefetch" href="/assets/js/43.7dc96afd.js"><link rel="prefetch" href="/assets/js/44.e2f0c7ee.js"><link rel="prefetch" href="/assets/js/45.31f66059.js"><link rel="prefetch" href="/assets/js/46.890ec337.js"><link rel="prefetch" href="/assets/js/47.5974e781.js"><link rel="prefetch" href="/assets/js/48.d9fee8f5.js"><link rel="prefetch" href="/assets/js/49.20b80a76.js"><link rel="prefetch" href="/assets/js/5.81cb8194.js"><link rel="prefetch" href="/assets/js/50.38a5880c.js"><link rel="prefetch" href="/assets/js/51.33730e88.js"><link rel="prefetch" href="/assets/js/53.fbf088d1.js"><link rel="prefetch" href="/assets/js/54.289575b6.js"><link rel="prefetch" href="/assets/js/55.10f3f573.js"><link rel="prefetch" href="/assets/js/56.9cbca336.js"><link rel="prefetch" href="/assets/js/57.656382af.js"><link rel="prefetch" href="/assets/js/58.75b0312b.js"><link rel="prefetch" href="/assets/js/59.4b346520.js"><link rel="prefetch" href="/assets/js/6.207bc2b8.js"><link rel="prefetch" href="/assets/js/60.d1cd85ac.js"><link rel="prefetch" href="/assets/js/61.5ef7fe13.js"><link rel="prefetch" href="/assets/js/62.fd0b6eba.js"><link rel="prefetch" href="/assets/js/63.dd2a49fa.js"><link rel="prefetch" href="/assets/js/64.22436f08.js"><link rel="prefetch" href="/assets/js/65.8b660d05.js"><link rel="prefetch" href="/assets/js/66.b2c5589a.js"><link rel="prefetch" href="/assets/js/67.9db74f9c.js"><link rel="prefetch" href="/assets/js/68.ec6ed826.js"><link rel="prefetch" href="/assets/js/69.d3314682.js"><link rel="prefetch" href="/assets/js/70.5b25f7a2.js"><link rel="prefetch" href="/assets/js/71.7fc89c14.js"><link rel="prefetch" href="/assets/js/72.2062880e.js"><link rel="prefetch" href="/assets/js/73.13101a92.js"><link rel="prefetch" href="/assets/js/74.b470bb0b.js"><link rel="prefetch" href="/assets/js/75.0dae0849.js"><link rel="prefetch" href="/assets/js/76.a666dd13.js"><link rel="prefetch" href="/assets/js/77.efdf08cd.js"><link rel="prefetch" href="/assets/js/8.3456d6aa.js"><link rel="prefetch" href="/assets/js/9.bb0354b3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3bf0f48a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-meteorlxy"><header class="header" data-v-7a046aea><div data-v-e4145d0a data-v-7a046aea><nav class="navbar" data-v-e4145d0a><div class="container" data-v-e4145d0a><a href="/" class="router-link-active" data-v-e4145d0a><span class="navbar-site-name" data-v-e4145d0a>
          teefing休憩小站
        </span></a> <div class="navbar-toggler" data-v-e4145d0a><svg class="icon" style="font-size:1.2em;" data-v-e4145d0a data-v-e4145d0a><title data-v-e4145d0a data-v-e4145d0a>menu</title><use xlink:href="#icon-menu" data-v-e4145d0a data-v-e4145d0a></use></svg></div> <div class="navbar-links" data-v-e4145d0a><a href="/" class="navbar-link" data-v-e4145d0a>
            首页
          </a><a href="/posts/" class="navbar-link router-link-active" data-v-e4145d0a>
            搜索
          </a></div></div></nav> <div class="navbar-holder" style="display:none;" data-v-e4145d0a></div></div> <div class="banner" data-v-98d6aa8c data-v-7a046aea data-v-7a046aea><div class="container" data-v-98d6aa8c><div class="center" data-v-98d6aa8c><h1 data-v-98d6aa8c data-v-7a046aea>
          nodejs流
        </h1></div></div></div></header> <div class="container clearfix show-aside" data-v-4dd605a1 data-v-4dd605a1><main class="main" data-v-4dd605a1><div class="post" data-v-4dd605a1 data-v-4dd605a1><section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-06-25
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : Invalid Date
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/06/23/nodejs%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" class="post-link" data-v-4e23451f>
      上一篇 : Node.js 最佳实践
    </a> <a href="/posts/2020/08/05/xhr.html" class="post-link" data-v-4e23451f>
      下一篇 : XMLHttpRequest思维导图
    </a></section></section> <article class="main-div"><div class="post-content content content__default"><h2 id="引子"><a href="#引子" class="header-anchor">#</a> 引子</h2> <blockquote><p>在编写代码时，我们应该有一些方法将程序像连接水管一样连接起来 -- 当我们需要获取一些数据时，可以去通过&quot;拧&quot;其他的部分来达到目的。这也应该是 IO 应有的方式。 -- <a href="https://www.bell-labs.com/usr/dmr/www/mdmpipe.html" target="_blank" rel="noopener noreferrer">Doug McIlroy. October 11, 1964<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>从<a href="http://www.youtube.com/watch?v=tc4ROCJYbm0" target="_blank" rel="noopener noreferrer">早先的 unix<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>开始，stream 便开始进入了人们的视野，在过去的几十年的时间里，它被证明是一种可依赖的编程方式，它可以将一个大型的系统拆成一些很小的部分，并且让这些部分之间完美地进行合作。在 unix 中，我们可以使用<code>|</code>符号来实现流。在 node 中，node 内置的<a href="http://nodejs.org/docs/latest/api/stream.html" target="_blank" rel="noopener noreferrer">stream 模块<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>已经被多个核心模块使用，同时也可以被用户自定义的模块使用。和 unix 类似，node 中的流模块的基本操作符叫做<code>.pipe()</code>，同时你也可以使用一个后压机制来应对那些对数据消耗较慢的对象。</p> <p>在 node 中，流可以帮助我们将事情的重点分为几份，因为使用流可以帮助我们将实现接口的部分分割成一些连续的接口，这些接口都是可重用的。接着，你可以将一个流的输出口接到另一个流的输入口，然后使用使用一些库来对流实现高级别的控制。</p> <p>对于小型程序设计(small-program design)以及 unix 哲学来说，流都是一个重要的组成部分，但是除此之外还有一些重要的事情值得我们思考。永远要记得：双鸟在林不如一鸟在手。</p> <h2 id="为什么应该使用流"><a href="#为什么应该使用流" class="header-anchor">#</a> 为什么应该使用流</h2> <p>在 node 中，I/O 都是异步的，所以在和硬盘以及网络的交互过程中会涉及到传递回调函数的过程。你之前可能会写出这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&quot;/data.txt&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的这段代码并没有什么问题，但是在每次请求时，我们都会把整个<code>data.txt</code>文件读入到内存中，然后再把结果返回给客户端。想想看，如果<code>data.txt</code>文件非常大，在响应大量用户的并发请求时，程序可能会消耗大量的内存，这样很可能会造成用户连接缓慢的问题。</p> <p>其次，上面的代码可能会造成很不好的用户体验，因为用户在接收到任何的内容之前首先需要等待程序将文件内容完全读入到内存中。</p> <p>所幸的是，<code>(req,res)</code>参数都是流对象，这意味着我们可以使用一种更好的方法来实现上面的需求：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&quot;/data.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在这里，<code>.pipe()</code>方法会自动帮助我们监听<code>data</code>和<code>end</code>事件。上面的这段代码不仅简洁，而且<code>data.txt</code>文件中每一小段数据都将源源不断的发送到客户端。</p> <p>除此之外，使用<code>.pipe()</code>方法还有别的好处，比如说它可以自动控制后端压力，以便在客户端连接缓慢的时候 node 可以将尽可能少的缓存放到内存中。</p> <p>想要将数据进行压缩？我们可以使用相应的流模块完成这项工作!</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> oppressor <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;oppressor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> stream <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createReadStream</span><span class="token punctuation">(</span>__dirname <span class="token operator">+</span> <span class="token string">&quot;/data.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">oppressor</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>通过上面的代码，我们成功的将发送到浏览器端的数据进行了 gzip 压缩。我们只是使用了一个 oppressor 模块来处理这件事情。</p> <p>一旦你学会使用流 api，你可以将这些流模块像搭乐高积木或者像连接水管一样拼凑起来，从此以后你可能再也不会去使用那些没有流 API 的模块获取和推送数据了。</p> <h2 id="流模块基础"><a href="#流模块基础" class="header-anchor">#</a> 流模块基础</h2> <p>在 node 中，一共有五种类型的流：readable,writable,transform,duplex 以及&quot;classic&quot;</p> <h3 id="pipe"><a href="#pipe" class="header-anchor">#</a> pipe</h3> <p>无论哪一种流，都会使用<code>.pipe()</code>方法来实现输入和输出。</p> <p><code>.pipe()</code>函数很简单，它仅仅是接受一个源头<code>src</code>并将数据输出到一个可写的流<code>dst</code>中：</p> <div class="language-js extra-class"><pre class="language-js"><code>src<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>.pipe(dst)</code>将会返回<code>dst</code>因此你可以链式调用多个流:</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>上面的代码也可以等价为：</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
c<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这和你在 unix 中编写流代码很类似：</p> <div class="language- extra-class"><pre class="language-text"><code>a | b | c | d
</code></pre></div><p>只不过此时你是在 node 中编写而不是在 shell 中！</p> <h3 id="readable-流"><a href="#readable-流" class="header-anchor">#</a> readable 流</h3> <p>Readable 流可以产出数据，你可以将这些数据传送到一个 writable，transform 或者 duplex 流中，只需要调用<code>pipe()</code>方法:</p> <div class="language-js extra-class"><pre class="language-js"><code>readableStream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="创建一个-readable-流"><a href="#创建一个-readable-流" class="header-anchor">#</a> 创建一个 readable 流</h4> <p>现在我们就来创建一个 readable 流！</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Readable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Readable<span class="token punctuation">;</span>
<span class="token keyword">var</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;beep &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;boop\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>下面运行代码：</p> <div class="language- extra-class"><pre class="language-text"><code>$ node read0.js
beep boop
</code></pre></div><p>在上面的代码中<code>rs.push(null)</code>的作用是告诉<code>rs</code>输出数据应该结束了。</p> <p>需要注意的一点是我们在将数据输出到<code>process.stdout</code>之前已经将内容推送进 readable 流<code>rs</code>中，但是所有的数据依然是可写的。</p> <p>这是因为在你使用<code>.push()</code>将数据推进一个 readable 流中时，一直要到另一个东西来消耗数据之前，数据都会存在一个缓存中。</p> <p>然而，在更多的情况下，我们想要的是当需要数据时数据才会产生，以此来避免大量的缓存数据。</p> <p>我们可以通过定义一个<code>._read</code>函数来实现按需推送数据:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Readable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Readable<span class="token punctuation">;</span>
<span class="token keyword">var</span> rs <span class="token operator">=</span> <span class="token function">Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">97</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function-variable function">_read</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>c<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;</span> <span class="token string">&quot;z&quot;</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码的运行结果如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>$ node read1.js
abcdefghijklmnopqrstuvwxyz
</code></pre></div><p>在这里我们将字母<code>a</code>到<code>z</code>推进了 rs 中，但是只有当数据消耗者出现时，数据才会真正实现推送。</p> <p><code>_read</code>函数也可以获取一个<code>size</code>参数来指明消耗者想要读取多少比特的数据，但是这个参数是可选的。</p> <p>需要注意到的是你可以使用<code>util.inherit()</code>来继承一个 Readable 流。</p> <p>为了说明只有在数据消耗者出现时，<code>_read</code>函数才会被调用，我们可以将上面的代码简单的修改一下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Readable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Readable<span class="token punctuation">;</span>
<span class="token keyword">var</span> rs <span class="token operator">=</span> <span class="token function">Readable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">97</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function-variable function">_read</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> <span class="token string">&quot;z&quot;</span><span class="token punctuation">.</span><span class="token function">charCodeAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span><span class="token operator">++</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
rs<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;exit&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&quot;\n_read() called &quot;</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c <span class="token operator">-</span> <span class="token number">97</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot; times&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdout<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;error&quot;</span><span class="token punctuation">,</span> process<span class="token punctuation">.</span>exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行上面的代码我们可以发现如果我们只请求 5 比特的数据，那么<code>_read</code>只会运行 5 次：</p> <div class="language- extra-class"><pre class="language-text"><code>$ node read2.js | head -c5
abcde
_read() called 5 times
</code></pre></div><p>在上面的代码中，<code>setTimeout</code>很重要，因为操作系统需要花费一些时间来发送程序结束信号。</p> <p>另外,<code>process.stdout.on('error',fn)</code>处理器也很重要，因为当<code>head</code>不再关心我们的程序输出时，操作系统将会向我们的进程发送一个<code>SIGPIPE</code>信号，此时<code>process.stdout</code>将会捕获到一个<code>EPIPE</code>错误。</p> <p>上面这些复杂的部分在和操作系统相关的交互中是必要的，但是如果你直接和 node 中的流交互的话，则可有可无。</p> <p>如果你创建了一个 readable 流，并且想要将任何的值推送到其中的话，确保你在创建流的时候指定了 objectMode 参数,<code>Readable({ objectMode: true })</code>。</p> <h4 id="消耗一个-readable-流"><a href="#消耗一个-readable-流" class="header-anchor">#</a> 消耗一个 readable 流</h4> <p>大部分时候，将一个 readable 流直接 pipe 到另一种类型的流或者使用 through 或者 concat-stream 创建的流中，是一件很容易的事情。但是有时我们也会需要直接来消耗一个 readable 流。</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;readable&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> buf <span class="token operator">=</span> process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码运行结果如下所示：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token punctuation">(</span>echo abc<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> def<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> ghi<span class="token punctuation">)</span> <span class="token operator">|</span> node consume0.js
<span class="token operator">&lt;</span>Buffer <span class="token number">61</span> <span class="token number">62</span> <span class="token number">63</span> 0a<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>Buffer <span class="token number">64</span> <span class="token number">65</span> <span class="token number">66</span> 0a<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>Buffer <span class="token number">67</span> <span class="token number">68</span> <span class="token number">69</span> 0a<span class="token operator">&gt;</span>
null
</code></pre></div><p>当数据可用时，<code>readable</code>事件将会被触发，此时你可以调用<code>.read()</code>方法来从缓存中获取这些数据。</p> <p>当流结束时，<code>.read()</code>将返回<code>null</code>，因为此时已经没有更多的字节可以供我们获取了。</p> <p>你也可以告诉<code>.read()</code>方法来返回<code>n</code>个字节的数据。虽然所有核心对象中的流都支持这种方式，但是对于对象流来说这种方法并不可用。</p> <p>下面是一个例子，在这里我们制定每次读取 3 个字节的数据：</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;readable&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> buf <span class="token operator">=</span> process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行上面的例子，我们将获取到不完整的数据:</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token punctuation">(</span>echo abc<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> def<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> ghi<span class="token punctuation">)</span> <span class="token operator">|</span> node consume1.js
<span class="token operator">&lt;</span>Buffer <span class="token number">61</span> <span class="token number">62</span> <span class="token number">6</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>
<span class="token operator">&lt;</span>Buffer 0a <span class="token number">64</span> <span class="token number">6</span><span class="token operator"><span class="token file-descriptor important">5</span>&gt;</span>
<span class="token operator">&lt;</span>Buffer <span class="token number">66</span> 0a <span class="token number">6</span><span class="token operator"><span class="token file-descriptor important">7</span>&gt;</span>
</code></pre></div><p>这是因为多余的数据都留在了内部的缓存中，因此这个时候我们需要告诉 node 我们还对剩下的数据感兴趣，我们可以使用<code>.read(0)</code>来完成这件事：</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;readable&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> buf <span class="token operator">=</span> process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
  process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>到现在为止我们的代码和我们所期望的一样了！</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token punctuation">(</span>echo abc<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> def<span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token builtin class-name">echo</span> ghi<span class="token punctuation">)</span> <span class="token operator">|</span> node consume2.js
<span class="token operator">&lt;</span>Buffer <span class="token number">61</span> <span class="token number">62</span> <span class="token number">6</span><span class="token operator"><span class="token file-descriptor important">3</span>&gt;</span>
<span class="token operator">&lt;</span>Buffer 0a <span class="token number">64</span> <span class="token number">6</span><span class="token operator"><span class="token file-descriptor important">5</span>&gt;</span>
<span class="token operator">&lt;</span>Buffer <span class="token number">66</span> 0a <span class="token number">6</span><span class="token operator"><span class="token file-descriptor important">7</span>&gt;</span>
<span class="token operator">&lt;</span>Buffer <span class="token number">68</span> <span class="token number">69</span> 0a<span class="token operator">&gt;</span>
</code></pre></div><p>我们也可以使用<code>.unshift()</code>方法来放置多余的数据。</p> <p>使用<code>unshift()</code>方法能够防止我们进行不必要的缓存拷贝。在下面的代码中我们将创建一个分割新行的可读解析器:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;readable&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> buf <span class="token operator">=</span> process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>buf<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> offset <span class="token operator">&lt;</span> buf<span class="token punctuation">.</span>length<span class="token punctuation">;</span> offset<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>buf<span class="token punctuation">[</span>offset<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token number">0x0a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>buf<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      buf <span class="token operator">=</span> buf<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>offset <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      offset <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码的运行结果如下所示：</p> <div class="language-bash extra-class"><pre class="language-bash"><code>$ <span class="token function">tail</span> -n +50000 /usr/share/dict/american-english <span class="token operator">|</span> <span class="token function">head</span> -n10 <span class="token operator">|</span> node lines.js
<span class="token string">'hearties'</span>
<span class="token string">'heartiest'</span>
<span class="token string">'heartily'</span>
<span class="token string">'heartiness'</span>
<span class="token string">'heartiness\'s'</span>
<span class="token string">'heartland'</span>
<span class="token string">'heartland\'s'</span>
<span class="token string">'heartlands'</span>
<span class="token string">'heartless'</span>
<span class="token string">'heartlessly'</span>
</code></pre></div><p>当然，已经有很多这样的模块比如 split 来帮助你完成这件事情，你完全不需要自己写一个。</p> <h3 id="writable-流"><a href="#writable-流" class="header-anchor">#</a> writable 流</h3> <p>一个 writable 流指的是只能流进不能流出的流:</p> <div class="language-js extra-class"><pre class="language-js"><code>src<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>writableStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="创建一个-writable-流"><a href="#创建一个-writable-流" class="header-anchor">#</a> 创建一个 writable 流</h4> <p>只需要定义一个<code>._write(chunk,enc,next)</code>函数，你就可以将一个 readable 流的数据释放到其中：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Writable <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Writable<span class="token punctuation">;</span>
<span class="token keyword">var</span> ws <span class="token operator">=</span> <span class="token function">Writable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ws<span class="token punctuation">.</span><span class="token function-variable function">_write</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">chunk<span class="token punctuation">,</span> enc<span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>chunk<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>ws<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>代码运行结果如下所示：</p> <div class="language- extra-class"><pre class="language-text"><code>$ (echo beep; sleep 1; echo boop) | node write0.js
&lt;Buffer 62 65 65 70 0a&gt;
&lt;Buffer 62 6f 6f 70 0a&gt;
</code></pre></div><p>第一个参数，<code>chunk</code>代表写进来的数据。</p> <p>第二个参数<code>enc</code>代表编码的字符串，但是只有在<code>opts.decodeString</code>为<code>false</code>的时候你才可以写一个字符串。</p> <p>第三个参数，<code>next(err)</code>是一个回调函数，使用这个回调函数你可以告诉数据消耗者可以写更多的数据。你可以有选择性的传递一个错误对象<code>error</code>，这时会在流实体上触发一个<code>emit</code>事件。</p> <p>在从一个 readable 流向一个 writable 流传数据的过程中，数据会自动被转换为<code>Buffer</code>对象，除非你在创建 writable 流的时候制定了<code>decodeStrings</code>参数为<code>false</code>,<code>Writable({decodeStrings: false})</code>。</p> <p>如果你需要传递对象，需要指定<code>objectMode</code>参数为<code>true</code>，<code>Writable({ objectMode: true })</code>。</p> <h4 id="向一个-writable-流中写东西"><a href="#向一个-writable-流中写东西" class="header-anchor">#</a> 向一个 writable 流中写东西</h4> <p>如果你需要向一个 writable 流中写东西，只需要调用<code>.write(data)</code>即可。</p> <p>process.stdout.write('beep boop\n');</p> <p>为了告诉一个 writable 流你已经写完毕了，只需要调用<code>.end()</code>方法。你也可以使用<code>.end(data)</code>在结束前再写一些数据。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> ws <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">createWriteStream</span><span class="token punctuation">(</span><span class="token string">&quot;message.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ws<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">&quot;beep &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ws<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">&quot;boop\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行结果如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>$ node writing1.js
   $ cat message.txt
beep boop
</code></pre></div><p>如果你需要调整内部缓冲区大小，那么需要在创建可写流对象时设置<code>highWaterMark</code>。在调用<code>.write()</code>方法返回 false 时，说明写入的数据大小超过了该值。</p> <p>为了避免读写速率不匹配而造成内存上涨，可以监听<code>drain</code>事件，等待可写流内部缓存被清空再继续写入。</p> <h3 id="transform-流"><a href="#transform-流" class="header-anchor">#</a> transform 流</h3> <p>你可以将 transform 流想象成一个流的中间部分，它可以读也可写，但是并不保存数据，它只负责处理流经它的数据。</p> <h3 id="duplex-流"><a href="#duplex-流" class="header-anchor">#</a> duplex 流</h3> <p>Duplex 流是一个可读也可写的流，就好像一个电话，可以接收也可以发送语音。一个 rpc 交换是一个 duplex 流的最好的例子。如果你看到过下面这样的代码：</p> <div class="language-js extra-class"><pre class="language-js"><code>a<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>那么你需要处理的就是一个 duplex 流对象。</p> <h3 id="classic-流"><a href="#classic-流" class="header-anchor">#</a> classic 流</h3> <p>Classic 流是一个古老的接口，最早出现在 node 0.4 中。虽然现在不怎么用，但是我们最好还是来了解一下它的工作原理。</p> <p>无论何时，只要一个流对象注册了一个<code>data</code>监听器，它就会自动的切换到<code>classic</code>模式，并且根据旧 API 的方式运行。</p> <h4 id="classic-readable-流"><a href="#classic-readable-流" class="header-anchor">#</a> classic readable 流</h4> <p>Classic readable 流只是一个事件发射器，当有数据消耗者出现时发射<code>emit</code>事件，当输出数据完毕时发射<code>end</code>事件。</p> <p>我们可以同构检查<code>stream.readable</code>来检查一个 classic 流对象是否可读。</p> <p>下面是一个简单的 readable 流对象的例子，程序的运行结果将会输出<code>A</code>到<code>J</code>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> Stream <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> stream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stream<span class="token punctuation">.</span>readable <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> iv <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>c <span class="token operator">&gt;=</span> <span class="token number">75</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clearInterval</span><span class="token punctuation">(</span>iv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    stream<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> stream<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stream<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>process<span class="token punctuation">.</span>stdout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行结果如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>$ node classic0.js
ABCDEFGHIJ
</code></pre></div><p>为了从一个 classic readable 流中读取数据，你可以注册<code>data</code>和<code>end</code>监听器。下面是一个使用旧 readable 流方式从<code>process.stdin</code>中读取数据的例子:</p> <div class="language-js extra-class"><pre class="language-js"><code>process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;data&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">buf</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&quot;end&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;**END**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>运行结果如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>$ (echo beep; sleep 1; echo boop) | node classic1.js
&lt;Buffer 62 65 65 70 0a&gt;
&lt;Buffer 62 6f 6f 70 0a&gt;
**END**
</code></pre></div><p>需要注意的一点是当你在一个流对象上注册了一个<code>data</code>监听器，你就将这个流放在了兼容模式下，此时你不能使用两个 stream2 的 api。</p> <p>如果你自己创建流对象，永远不要绑定<code>data</code>和<code>end</code>监听器。如果你需要和旧版本的流兼容，最好使用第三方库来实现<code>.pipe()</code>方法。</p> <p>例如，你可以使用 through 模块来避免显式的使用<code>data</code>和<code>end</code>监听器:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> through <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;through&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span><span class="token function">through</span><span class="token punctuation">(</span>write<span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token parameter">buf</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;**END**&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>程序运行结果如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>$ (echo beep; sleep 1; echo boop) | node through.js
&lt;Buffer 62 65 65 70 0a&gt;
&lt;Buffer 62 6f 6f 70 0a&gt;
**END**
</code></pre></div><p>你也可以使用 concat-stream 模块来将整个流的内容缓存起来:</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> concat <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;concat-stream&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
process<span class="token punctuation">.</span>stdin<span class="token punctuation">.</span><span class="token function">pipe</span><span class="token punctuation">(</span>
  <span class="token function">concat</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">body</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>body<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>程序运行结果如下所示:</p> <div class="language- extra-class"><pre class="language-text"><code>$ echo '{&quot;beep&quot;:&quot;boop&quot;}' | node concat.js
{ beep: 'boop' }
</code></pre></div><p>Classic readable 流拥有<code>.pause()</code>和<code>.resume()</code>逻辑来暂停一个流，但是这都是可选的。如果你想要使用<code>.pause()</code>和<code>.resume()</code>方法，你应该使用 through 模块来帮助你处理缓存。</p> <h4 id="classic-writable-流"><a href="#classic-writable-流" class="header-anchor">#</a> classic writable 流</h4> <p>Classic writable 流非常简单。其中只定义了<code>.write(buf)</code>，<code>.end(buf)</code>，以及<code>.desctory()</code>方法。其中<code>.end(buf)</code>的参数 buf 是可选参数，但是一般来说 node 程序员还是喜欢使用<code>.end(buf)</code>这种写法。</p> <h2 id="接下来读什么"><a href="#接下来读什么" class="header-anchor">#</a> 接下来读什么</h2> <ul><li><a href="http://nodejs.org/docs/latest/api/stream.html#stream_stream" target="_blank" rel="noopener noreferrer">node 核心 stream 模块文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>你可以使用<a href="(https://npmjs.org/package/readable-stream)">readable-stream</a>模块来确保你的 stream2 代码兼容 node 0.8 及其之前的代码。在你<code>npm install readable-stream</code>之后直接<code>require('readable-stream')</code>而不要<code>require('stream')</code>。</li></ul> <hr> <p>本文参考自 stream-handbook，原文地址https://github.com/substack/stream-handbook</p></div></article> <section class="post-meta main-div" data-v-4e23451f><section class="post-date clearfix" data-v-4e23451f><span class="create-date" data-v-4e23451f>
      发布时间 : 2020-06-25
    </span> <span class="update-date" data-v-4e23451f>
      最后修改 : Invalid Date
    </span></section> <section class="post-links" data-v-4e23451f><a href="/posts/2020/06/23/nodejs%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5.html" class="post-link" data-v-4e23451f>
      上一篇 : Node.js 最佳实践
    </a> <a href="/posts/2020/08/05/xhr.html" class="post-link" data-v-4e23451f>
      下一篇 : XMLHttpRequest思维导图
    </a></section></section> <div id="post-comments" class="main-div"><!----></div></div></main> <aside class="aside" data-v-4dd605a1><div class="info-card main-div" data-v-9d847660 data-v-4dd605a1><div class="info-card-header" style="background-size:cover;background-repeat:no-repeat;background-position:center;background-attachment:scroll;background-image:url(https://api.ixiaowai.cn/gqapi/gqapi.php);" data-v-9d847660><img src="https://image.teefing.top/wutiao.jpg" alt="阿波罗吹雪" class="info-avatar" data-v-9d847660></div> <div class="info-card-body" data-v-9d847660><section class="info-nickname" data-v-9d847660>
      阿波罗吹雪
    </section> <section class="info-desc" data-v-9d847660>
      <span style="background: linear-gradient(to right, red, blue);-webkit-background-clip: text;color: transparent;">我思我想故我在</span>
      <br>
      <span style="background: linear-gradient(to right, orange, navy);-webkit-background-clip: text;color: transparent;">爱上青天等风来</span>
      <br>
      <span style="background: linear-gradient(to right, purple, #ff3b00);-webkit-background-clip: text;color: transparent;">前路前行不可怠</span>
      <br>
      <span style="background: linear-gradient(to right, green, #d25113);-webkit-background-clip: text;color: transparent;">端坐星河把天开</span>
      </section> <section class="info-contact" data-v-9d847660><section data-v-9d847660><span title="浙江杭州" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>浙江杭州</title><use xlink:href="#icon-location" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          浙江杭州
        </span></span></section> <section data-v-9d847660><span title="Hangzhou Normal University" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>Hangzhou Normal University</title><use xlink:href="#icon-organization" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          Hangzhou Normal University
        </span></span></section> <section data-v-9d847660><a href="mailto:tengfeitf@foxmail.com" title="tengfeitf@foxmail.com" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>tengfeitf@foxmail.com</title><use xlink:href="#icon-email" data-v-9d847660 data-v-9d847660></use></svg><span class="info-text" data-v-9d847660 data-v-9d847660>
          tengfeitf@foxmail.com
        </span></a></section></section></div> <div class="info-card-footer" data-v-9d847660><section class="info-sns clearfix" data-v-9d847660><a href="https://github.com/fantasticfbaby" target="_blank" class="sns-link" data-v-9d847660><span title="GitHub: fantasticfbaby" class="sns-icon" data-v-9d847660 data-v-9d847660><svg class="icon" style="font-size:1.5em;" data-v-9d847660 data-v-9d847660><title data-v-9d847660 data-v-9d847660>GitHub: fantasticfbaby</title><use xlink:href="#icon-github" data-v-9d847660 data-v-9d847660></use></svg></span></a></section></div></div> <div class="post-nav-card main-div" style="position:relative;top:0;width:0px;" data-v-4dd605a1><div class="post-nav-contents"><svg class="icon"><title>book</title><use xlink:href="#icon-book"></use></svg> <span>文章目录</span> <div class="post-nav-toc"><ul><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#引子">引子</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#为什么应该使用流">为什么应该使用流</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#流模块基础">流模块基础</a><ul><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#pipe">pipe</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#readable-流">readable 流</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#writable-流">writable 流</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#transform-流">transform 流</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#duplex-流">duplex 流</a></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#classic-流">classic 流</a></li></ul></li><li><a href="/posts/2020/06/25/nodejs%E6%B5%81.html#接下来读什么">接下来读什么</a></li></ul></div></div> <div class="post-nav-comments"><svg class="icon"><title>comment</title><use xlink:href="#icon-comment"></use></svg> <a href="/posts/2020/06/25/nodejs%E6%B5%81.html#post-comments">
      评论
    </a></div></div></aside></div> <footer class="footer" data-v-1375e54c><p class="footer-sns-links" data-v-1375e54c><a href="https://github.com/fantasticfbaby" target="_blank" class="sns-link" data-v-1375e54c><span title="GitHub: fantasticfbaby" class="sns-icon" data-v-1375e54c data-v-1375e54c><svg class="icon" style="font-size:25px;" data-v-1375e54c data-v-1375e54c><title data-v-1375e54c data-v-1375e54c>GitHub: fantasticfbaby</title><use xlink:href="#icon-github" data-v-1375e54c data-v-1375e54c></use></svg></span></a></p> <!----> <p class="footer-text" data-v-1375e54c>Copyright 2017-present <a href="https://github.com/fantasticfbaby" target="_blank">fantasticfbaby</a> | MIT License <br> <a href="https://beian.miit.gov.cn" target="_blank">备案号  浙ICP备17036569号-1</a></p></footer></div><div class="global-ui"><!----><!----><!----><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:65px;bottom:0px;width:200px;height:200px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="200" height="200" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:200px;height:200px;"></canvas></div></div></div>
    <script src="/assets/js/app.9da2ff31.js" defer></script><script src="/assets/js/7.8bf351e1.js" defer></script><script src="/assets/js/52.2d5e3f14.js" defer></script>
  </body>
</html>
